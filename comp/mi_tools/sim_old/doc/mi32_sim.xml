<?xml version="1.0" encoding="iso-8859-2"?>
<source>
   <component>MI32 Simulation Component for NETCOPE ICS</component>

   <authors>
      <author login="xkobie00">Petr Kobiersky</author>
   </authors>

   <features>
      <item>Generate mi32 read and write requests</item>
      <item>Usefull for component simulation</item>
      <item>Log outcoming and incoming transactions</item>
      <item>Functions for generating requests</item>
   </features>


   <description>
      Easy use component for creating mi32 read and write requests. Read and
      Write requests can be generated by function calls from testbench file.
      This component also support loging incoming and outcoming transaction
      in user readable file.
   </description>

   <interface>
      <generic_map>
         <generic name="UPSTREAM_LOG_FILE" type="string" default="">
			   Specify path to file where upstream transaction is loged.
         </generic>

		   <generic name="DOWNSTREAM_LOG_FILE" type="string" default="">
			   Specify path to file where downstream transaction is loged.
         </generic>

         <generic name="BASE_ADDR" type="std_logic_vector(31:0)" default="0x00000000">
			   Specify Endpoint base address.
         </generic>

		   <generic name="ADDR_WIDTH" type="integer" default="2147483647">
			   Specify addess width
         </generic>

		   <generic name="FREQUENCY" type="integer" default="LOCAL_BUS_FREQUENCY">
			   Specify user component frequency
         </generic>

		   <generic name="BUFFER_EN" type="boolean" default="false">
			   Enable or Disable endpoint buffer
         </generic>
      </generic_map>

      <port_map>
         <divider>Common Interface</divider>

         <port name="IB_CLK" dir="in" width="1">
            Internal Bus Clock.
         </port>

         <port name="IB_RESET" dir="in" width="1">
            Internal Bus Reset.
         </port>

         <divider>User Component Interface</divider>

         <port name="CLK" dir="in" width="1">
            User component CLK
         </port>

         <port name="MI32" dir="inout" width="t_mi32">
            MI32 interface
         </port>

     <divider>Simulation Interface</divider>

         <port name="STATUS" dir="out" width="t_ib_status">
            Status interface - Readed data is also send to this interface
         </port>

         <port name="CTRL" dir="in" width="t_ib_ctrl">
            Ctrl port - set command for IB_SIM command
         </port>

         <port name="STROBE" dir="in" width="1">
            Strobe command on CTRL port
         </port>

         <port name="BUSY" dir="out" width="1">
            IB_SIM is BUSY (sending or waiting for some read transaction)
         </port>
      </port_map>
   </interface>

   <body>

<!-- Here is description in standard Satrapa format-->
<h2>Informations</h2>
   <p>
      When you want to use MI32_SIM component ib_sim_oper package must be included <br/>
      <i>use work.ib_sim_oper.all; -- Internal Bus Simulation Package</i>
   </p>

   <p>
      Simulation interface of mi32_sim must be connected to folowing signal names:<br/>
      STATUS             => ib_sim_status <br/>
      CTRL               => ib_sim_ctrl   <br/>
      STROBE             => ib_sim_strobe <br/>
      BUSY               => ib_sim_busy   <br/>
   </p>

<h2>IB_OP procedure for testbench</h2>
   <p>
   This procedure must be placed to your testbench file. Using this procedure is
   MI32_SIM gets BUS operations.

   <pre>
   procedure ib_op(ctrl : in t_ib_ctrl) is
   begin
      wait until (IB_CLK'event and IB_CLK='1' and ib_sim_busy = '0');
      ib_sim_ctrl &lt;= ctrl;
      ib_sim_strobe &lt;= '1';
      wait until (IB_CLK'event and IB_CLK='1');
      ib_sim_strobe &lt;= '0';
   end ib_op;
   </pre>
   </p>


<h2>Supported commands for MI32_SIM</h2>
   <p>
   Result of this five functions can be used as a parametr for
   ib_op procedure.<br/>
   Ex. <i>ib_op(ib_local_write_file(16#22222220#, 64, "./tests/test_write0.txt"));</i>
   </p>

 <p>
   <b><i>Send Local Read Transaction</i></b>
   <pre>
   function ib_local_read(src_addr    : in std_logic_vector(31 downto 0); -- Address from where are data readed
                          dst_addr    : in std_logic_vector(31 downto 0); -- Destination address of completition transaction
                          length      : in integer;                       -- Number of bytes to be readed
                          tag         : in integer;                       -- Transaction Tag
                          read_wait   : in boolean:=false)                -- Wait for completition transaction
                     return t_ib_ctrl;
   </pre>

   <b><i>Send Local Read Transaction (Readed data is saved to file)</i></b>
   <pre>
   function ib_local_read_file(src_addr    : in std_logic_vector(31 downto 0); -- Address from where are data readed
                               dst_addr    : in std_logic_vector(31 downto 0); -- Destination address of completition transaction
                               length      : in integer;                       -- Number of bytes to be readed
                               tag         : in integer;                       -- Transaction Tag
                               file_name   : in string)                        -- Filename where are readed data saved (64 bit hexa values)
                     return t_ib_ctrl;
   </pre>

   <b><i>Send Local Write Transaction (up to 64 bits of data)</i></b>
   <pre>
   function ib_local_write(dst_addr   : in std_logic_vector(31 downto 0);  -- Destination addres of write transaction
                           src_addr   : in std_logic_vector(31 downto 0);  -- From where are write transaction generated
                           length     : in integer;                        -- Length of writen data
                           tag        : in integer;                        -- Transaction Tag
                           trans_flag : in std_logic;                      -- 0 - No ACK/ 1 - Write completition ACK
                           data       : in std_logic_vector(63 downto 0))  -- Data to be writen
                     return t_ib_ctrl;
   </pre>

   <b><i>Send Local Write Transaction (Write data from file)</i></b>
   <pre>
   function ib_local_write_file(dst_addr   : in std_logic_vector(31 downto 0); -- Destination address of write transaction
                                src_addr   : in std_logic_vector(31 downto 0); -- From where are write transaction generated
                                length     : in integer;                       -- Length of writen data (when 0 all data from file is writen)
                                tag        : in integer;                       -- Transaction Tag
                                trans_flag : in std_logic;                     -- 0 - No ACK/ 1 - Write completition ACK
                                file_name  : in string)                        -- Filename from where are data writen (64 bit hexa values)
                     return t_ib_ctrl;
   </pre>

   <b><i>Send Local Write Transaction (Write 32 bit data from file)</i></b>
   <pre>
   function ib_local_write_file32(dst_addr   : in std_logic_vector(31 downto 0); -- Destination address of write transaction
                                  src_addr   : in std_logic_vector(31 downto 0); -- From where are write transaction generated
                                  length     : in integer;                       -- Length of writen data (when 0 all data from file is writen)
                                  tag        : in integer;                       -- Transaction Tag
                                  trans_flag : in std_logic;                     -- 0 - No ACK/ 1 - Write completition ACK
                                  file_name  : in string)                        -- Filename from where are data writen (64 bit hexa values)
                     return t_ib_ctrl;
   </pre>
   </p>

<h2> Fixing bad behavior of MI32 Sim </h2>
   <p>
      Because of the fact that MI32 Sim was not written in the proper way and is
      in fact only a wrapper above the <ref_comp ref="ib_sim">IB Sim</ref_comp>
      component it fails to send transactions longer than 4 kB. If you need to
      write files with data longer than that limit you need to use workaround
      procedure shown below.
   </p>

   <p>
      <pre>
         -- This procedure fixes bad behavior of MI32 sim
         procedure send_mi32_file32(-- Destination address of the transaction
                                    constant dst_addr  : in std_logic_vector;
                                    -- Name of the file from which data is read
                                    constant file_name : in string
                                 ) is

            file in_file            : text;
            constant data32b        : std_logic_vector(31 downto 0) := (others => '0');
            variable file_status    : file_open_status;
            variable in_line        : line;
            variable data32a        : std_logic_vector(31 downto 0);
            variable len            : integer;
            variable act_dst_addr   : integer;
            variable read_flag      : boolean;

         begin
            -- open file
            file_open(file_status, in_file, file_name, READ_MODE);
            assert (file_status = OPEN_OK) report "File with data was not found!" severity ERROR;
            -- convert destination address to integer
            act_dst_addr := conv_integer(dst_addr);

            while (not(endfile(in_file))) loop
               -- read one line
               readline(in_file, in_line);
               hread(in_line, data32a, read_flag);
               assert read_flag report "send_mi32_file read error" severity ERROR;

               -- write 32 bits
               ib_op(ib_local_write(conv_std_logic_vector(act_dst_addr, 32),
                     X"11111111", 1, 16#ABAB#, '0', data32b &amp; data32a));
               act_dst_addr := act_dst_addr + 4;
            end loop;
            file_close(in_file);

         end send_mi32_file32;
      </pre>
   </p>

   <p>
      The procedure can be used to read a file that on each line contains a hexadecimal
      number representing 32-bit value to be written to the address
      <i>dst_addr + (line_number - 1) * 4</i>
   </p>

   <p>
      Note that you need to include files below in order to use previous procedure:
      <pre>
         -- Libraries needed to fix broken MI32 sim
         use std.textio.all;
         use IEEE.std_logic_textio.all;
      </pre>
   </p>
</body>
</source>
