

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rate Limiter &mdash; NDK-FPGA Docs  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme_overrides.css?v=b530091d" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Packet Delayer" href="../packet_delayer/readme.html" />
    <link rel="prev" title="MFB Enabler" href="../enabler/readme.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            NDK-FPGA Docs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Application:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../app-minimal.html">Minimal NDK application</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Network Development Kit:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/how_to_start.html">How to start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/terminology.html">NDK Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/readme.html">NDK Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/configuration.html">Configuration files and parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/testing.html">NDK testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_build/readme.html">Build System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/devtree.html">Device Tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_core/doc/faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Supported cards:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/reflexces/agi-fh400g/readme.html">ReflexCES XpressSX AGI-FH400G</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/intel/dk-dev-1sdx-p/readme.html">Intel Stratix 10 DX FPGA DK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/intel/dk-dev-agi027res/readme.html">Intel Agilex I-Series FPGA DK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/silicom/fb4cgg3/readme.html">Silicom fb4CGg3&#64;VU9P</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/silicom/fb2cghh/readme.html">Silicom fb2CGhh&#64;KU15P</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/silicom/n6010/readme.html">Silicom N6010</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/bittware/ia-420f/readme.html">Bittware IA-420F</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/amd/alveo-u200/readme.html">AMD Alveo U200</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/amd/alveo-u55c/readme.html">AMD Alveo U55C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/amd/vcu118/readme.html">AMD VCU118&#64;VU9P</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ndk_cards/prodesign/pd-falcon/readme.html">PRO DESIGN Falcon</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">VHDL components:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../base.html">Basic Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ctrls.html">Controllers &amp; TSU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mi.html">MI Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../mfb.html">MFB Tools</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../readme.html">MFB specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reconfigurator/readme.html">MFB Reconfigurator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame_packer/readme.html">Frame Packer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame_unpacker/readme.html">Frame Unpacker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../splitter_simple/readme.html">MFB Splitter Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../splitter_simple/readme.html#id1">MFB Splitter Simple Gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../merger_simple/readme.html">MFB Merger Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../merger_simple/readme.html#id1">MFB Merger Simple GEN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cutter_simple/readme.html">MFB Cutter Simple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dropper/readme.html">MFB Dropper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metadata_insertor/readme.html">Metadata Insertor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transformer/readme.html">MFB Trasformer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pipe/readme.html">MFB PIPE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../merger/readme.html">MFB Merger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../splitter/readme.html">MFB Splitter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../splitter/readme.html#id1">MFB Splitter Gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../enabler/readme.html">MFB Enabler</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Rate Limiter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operation">Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#address-space-and-configuration">Address space and configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../packet_delayer/readme.html">Packet Delayer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../timestamp_limiter/readme.html">Timestamp Limiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../loopback/readme.html">MFB Loopback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crossbarx_stream2/readme.html">CROSSBARX STREAM2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame_masker/readme.html">MFB Frame Masker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edit/frame_trimmer/readme.html">MFB FRAME TRIMMER</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../edit/frame_extender/readme.html">MFB FRAME EXTENDER</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logic/crossbarx_stream/readme.html">CrossbarX Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logic/checksum_calculator/readme.html">Checksum Calculator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../logic/auxiliary_signals/readme.html">MFB Auxiliary Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/pd_asfifo/readme.html">MFB Packet Discard ASFIFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/pd_asfifo_simple/readme.html">MFB PD ASFIFO SIMPLE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/asfifox/readme.html">MFB ASFIFOX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/fifox/readme.html">MFB FIFOX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../storage/crossbarx_output_buffer/readme.html">Crossbarx Output Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../debug/gen_loop_switch/readme.html">Gen Loop Switch (GLS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../debug/generator/readme.html">MFB Generator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mvb.html">MVB Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nic.html">Network Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pcie.html">PCIe Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../debug.html">Debug Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ver.html">UVM Verification</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NDK-FPGA Docs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../mfb.html">MFB Tools</a></li>
      <li class="breadcrumb-item active">Rate Limiter</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/comp/mfb_tools/flow/rate_limiter/readme.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rate-limiter">
<span id="id1"></span><h1>Rate Limiter<a class="headerlink" href="#rate-limiter" title="Link to this heading"></a></h1>
<p>The Rate limiter modifies the output speed according to the given configuration.
The user can set the speed to anything, from a constant rate to complex patterns, as needed for the specific application.</p>
<section id="operation">
<h2>Operation<a class="headerlink" href="#operation" title="Link to this heading"></a></h2>
<p>The component forwards the incoming data unchanged.
Based on the values loaded to the configuration registers, it either lets the traffic flow through at full speed or slows the traffic down when the limit of the configured rate is reached.
The user configures the output speed per each Interval (see the picture below).
Each Interval can be configured to a different throughput speed via the corresponding register in the address space.
The component loops over all configured Intervals, and after the last one, it starts again from the beginning.
The component can limit the output speed based on the number of either bytes or packets.</p>
<p>A maximum amount of Intervals can be configured, given by the INTERVAL_COUNT generic value.
Each Interval consists of an INTERVAL_LENGTH number of Sections, where every Section lasts SECTION_LENGTH clock cycles.
Within each Section, the incoming data stream flows through the component at full speed until the configured speed limit is reached.
Reaching the speed limit stops the flow completely, meaning the output speed is either full throughput or none.
The configured speed only determines the proportion between these two states.
At the end of the Section, the flow is restored (to full throughput), and the process is repeated in the next Section.
The component detects that the limit is reached with a delay of a few clock cycles (depending on the limiting type), so the actual amount of transmitted data won’t be exactly the configured limit.
This is solved by adding constants to the current amount of transferred data to ensure the limit is not surpassed.
Unfortunately, this approach is not ideal, and some configuration restrictions must be met for the component to function correctly (see the <a class="reference internal" href="#usage"><span class="std std-ref">Usage section</span></a>).</p>
<figure class="align-center" id="timespace">
<a class="reference internal image-reference" href="../../../../_images/timespace.svg"><img alt="../../../../_images/timespace.svg" src="../../../../_images/timespace.svg" style="width: 100%;" />
</a>
</figure>
<ul class="simple">
<li><p>INTERVAL_COUNT  = 8 intervals</p></li>
<li><p>INTERVAL_LENGTH = 16 sections</p></li>
<li><p>SECTION_LENGTH  = default 1000 ticks of the clock signal</p></li>
<li><p>The arrows illustrate the moments when the flow of data is restored.</p></li>
<li><p>The speeds are switched in the following order: 10Gb/s, 50Gb/s, 0Gb/s, 75Gb/s, 60Gb/s, 10Gb/s, … and so on.</p></li>
</ul>
<p>The component’s default configuration is set to transfer data at full speed.
Whether the speed value is given to the component directly via the generic OUTPUT_SPEED or configured after the start, it has to be recalculated to bytes per Section (or packets per Section).
See the Speed conversions and Adjusting Section Length sections below.
This way, any conversions in the firmware can be omitted, which simplifies the logic.</p>
<dl class="vhdl autoentity">
<dt class="sig sig-object vhdl" id="vhdl-entity-rate_limiter">
<span class="k"><span class="pre">ENTITY</span> </span><span class="sig-name descname"><span class="pre">RATE_LIMITER</span></span><span class="k"> <span class="pre">IS</span></span><a class="headerlink" href="#vhdl-entity-rate_limiter" title="Link to this definition"></a></dt>
<dd><span class="sig-name descname">Generics</span><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Generic</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-mi_data_width"><td><p>MI_DATA_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>MI Data word width (in bits)</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-mi_addr_width"><td><p>MI_ADDR_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>MI Address word width (in bits)</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-mfb_regions"><td><p>MFB_REGIONS</p></td>
<td><p>natural</p></td>
<td><p>1</p></td>
<td><p>Number of MFB regions (rx and tx)</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-mfb_region_size"><td><p>MFB_REGION_SIZE</p></td>
<td><p>natural</p></td>
<td><p>8</p></td>
<td><p>MFB region size (in number of blocks)</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-mfb_block_size"><td><p>MFB_BLOCK_SIZE</p></td>
<td><p>natural</p></td>
<td><p>8</p></td>
<td><p>MFB block size (in number of items)</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-mfb_item_width"><td><p>MFB_ITEM_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>8</p></td>
<td><p>MFB item width (in bits)</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-mfb_meta_width"><td><p>MFB_META_WIDTH</p></td>
<td><p>natural</p></td>
<td><p>0</p></td>
<td><p>MFB metadata width (in bits)</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-section_length"><td><p>SECTION_LENGTH</p></td>
<td><p>natural</p></td>
<td><p>1000</p></td>
<td><p>Default section length (in number of clock cycles)
Maximum: 2**MI_DATA_WIDTH</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-interval_length"><td><p>INTERVAL_LENGTH</p></td>
<td><p>natural</p></td>
<td><p>40</p></td>
<td><p>Default interval length (in number of sections)
Maximum: 2**MI_DATA_WIDTH</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-interval_count"><td><p>INTERVAL_COUNT</p></td>
<td><p>natural</p></td>
<td><p>32</p></td>
<td><p>Maximum number of intervals (different speed registers)</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-output_speed"><td><p>OUTPUT_SPEED</p></td>
<td><p>natural</p></td>
<td><p>62500</p></td>
<td><p>Default output speed (in bytes per section or packets per section)</p></td>
</tr>
<tr class="row-odd" id="vhdl-gengeneric-rate_limiter-frequency"><td><p>FREQUENCY</p></td>
<td><p>natural</p></td>
<td><p>200</p></td>
<td><p>Operating frequency in MHz (used in SW for calculation of output speed)</p></td>
</tr>
<tr class="row-even" id="vhdl-gengeneric-rate_limiter-device"><td><p>DEVICE</p></td>
<td><p>string</p></td>
<td><p>“AGILEX”</p></td>
<td><p>Target device</p></td>
</tr>
</tbody>
</table>
<span class="sig-name descname">Ports</span><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Port</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Mode</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-clk"><td><p>CLK</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td><p>Clock and Reset</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-reset"><td><p>RESET</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-mi_dwr"><td><p>MI_DWR</p></td>
<td><p>std_logic_vector(MI_DATA_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>MI configuration interface</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-mi_addr"><td><p>MI_ADDR</p></td>
<td><p>std_logic_vector(MI_ADDR_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-mi_rd"><td><p>MI_RD</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-mi_wr"><td><p>MI_WR</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-mi_be"><td><p>MI_BE</p></td>
<td><p>std_logic_vector((MI_DATA_WIDTH/8)-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-mi_drd"><td><p>MI_DRD</p></td>
<td><p>std_logic_vector(MI_DATA_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-mi_ardy"><td><p>MI_ARDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-mi_drdy"><td><p>MI_DRDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-rx_mfb_data"><td><p>RX_MFB_DATA</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_REGION_SIZE*MFB_BLOCK_SIZE*MFB_ITEM_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td><p>MFB input interface</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-rx_mfb_meta"><td><p>RX_MFB_META</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_META_WIDTH-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-rx_mfb_sof"><td><p>RX_MFB_SOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-rx_mfb_eof"><td><p>RX_MFB_EOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-rx_mfb_sof_pos"><td><p>RX_MFB_SOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1, log2(MFB_REGION_SIZE))-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-rx_mfb_eof_pos"><td><p>RX_MFB_EOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1, log2(MFB_REGION_SIZE*MFB_BLOCK_SIZE))-1 downto 0)</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-rx_mfb_src_rdy"><td><p>RX_MFB_SRC_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-rx_mfb_dst_rdy"><td><p>RX_MFB_DST_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-tx_mfb_data"><td><p>TX_MFB_DATA</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_REGION_SIZE*MFB_BLOCK_SIZE*MFB_ITEM_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td><p>MFB output interface</p></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-tx_mfb_meta"><td><p>TX_MFB_META</p></td>
<td><p>std_logic_vector(MFB_REGIONS*MFB_META_WIDTH-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-tx_mfb_sof"><td><p>TX_MFB_SOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-tx_mfb_eof"><td><p>TX_MFB_EOF</p></td>
<td><p>std_logic_vector(MFB_REGIONS-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-tx_mfb_sof_pos"><td><p>TX_MFB_SOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1, log2(MFB_REGION_SIZE))-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-tx_mfb_eof_pos"><td><p>TX_MFB_EOF_POS</p></td>
<td><p>std_logic_vector(MFB_REGIONS*max(1, log2(MFB_REGION_SIZE*MFB_BLOCK_SIZE))-1 downto 0)</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-even" id="vhdl-portsignal-rate_limiter-tx_mfb_src_rdy"><td><p>TX_MFB_SRC_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>out</p></td>
<td></td>
</tr>
<tr class="row-odd" id="vhdl-portsignal-rate_limiter-tx_mfb_dst_rdy"><td><p>TX_MFB_DST_RDY</p></td>
<td><p>std_logic</p></td>
<td><p>in</p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="address-space-and-configuration">
<h2>Address space and configuration<a class="headerlink" href="#address-space-and-configuration" title="Link to this heading"></a></h2>
<p>The component has several registers accessible through the MI interface that are used for its configuration.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Address offset</p></th>
<th class="head"><p>Note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>status register</p></td>
</tr>
<tr class="row-odd"><td><p>0x04</p></td>
<td><p>section length register</p></td>
</tr>
<tr class="row-even"><td><p>0x08</p></td>
<td><p>interval length register</p></td>
</tr>
<tr class="row-odd"><td><p>0x0c</p></td>
<td><p>interval count register (read-only)</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>frequency (read-only)</p></td>
</tr>
<tr class="row-odd"><td><p>0x14</p></td>
<td><p>1st speed register</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>2nd speed register (INTERVAL_COUNT &gt; 1)</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x??</p></td>
<td><p>last speed register -&gt; 0x14 + (INTERVAL_COUNT-1)*4</p></td>
</tr>
</tbody>
</table>
<p>The data registers correspond with the information given in paragraph ‘Generic parameters’, and the status register fields are described below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SR Flag (bit)</p></th>
<th class="head"><p>Note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>idle flag (1 = idle - default, 0 = busy) (RO)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>configuration (W: 1 = start, 0 = stop) / is in configuration state (R)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>traffic shaping (W: 1 = start, 0 = stop) / traffic shaping is running (R)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>auxiliary flag (WO)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>reset pointer (W: 1 = reset pointer to the first configured speed) (WO)</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>limiting type (W: 1 = packet limiting, 0 = byte limiting - default) (RW)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="usage">
<span id="id2"></span><h2>Usage<a class="headerlink" href="#usage" title="Link to this heading"></a></h2>
<p><strong>Intro</strong></p>
<p>The status register is also used as a control register.
By setting its bits (flags), the user can change the working modes of the Rate Limiter and its settings.
Two types of flags can be set: state and auxiliary.
State flags indicate/set the working mode of the component:</p>
<ul class="simple">
<li><p>IDLE mode (default, no limiting applied; it is the full throughput mode),</p></li>
<li><p>CONFIGURATION mode (in which the user can change parameters such as the Section Length, Interval Length, and the Output Speed(s)), and</p></li>
<li><p>RUN mode (also the limiting mode, where traffic flows through at the configured speed(s)).</p></li>
</ul>
<p>The auxiliary flags (RESET POINTER and LIMITING TYPE) do not directly affect the traffic flow.
To distinguish between these two types of flags, use the AUXILIARY FLAG as follows: set it to 0 to change the state flags (i.e., leave it as it is) and to 1 to change the auxiliary flags.</p>
<p><strong>The modes</strong></p>
<p>Let’s run through an example to make it more straightforward.
The component starts in the IDLE state (Status register: <code class="docutils literal notranslate"><span class="pre">0b000001</span></code>).
The values of the other registers (Section Length register, Frequency register, etc.) will have default values set by the generic values of the component.
If this is good enough, you can transition straight to the RUN mode by writing <code class="docutils literal notranslate"><span class="pre">0b000100</span></code> to the Status register.</p>
<p>Otherwise, if you need to change some of the other-than-Status registers, you must first switch to the CONFIGURATION mode (<code class="docutils literal notranslate"><span class="pre">0b000010</span></code> -&gt; Status register).
Here, you can change the output speeds for all intervals (max number of intervals set by the INTERVAL_COUNT parameter at the build phase).
Multiple intervals might be useful when attempting some traffic-shaping mechanism.
You never have to set a value to all of the Speed registers.
Each of the Speed registers is automatically validated when a value is written to it (the Speed register’s MSB is set to ‘1’ - you can notice this when reading it back).
During the RUN mode, when the last Speed register with a valid speed is reached, it loops back to the first Speed register and starts all over again.
This implies that you must set consecutive Speed registers because the first invalid Speed register will restart the loop (e.g., even speed 0 must be written to be valid).</p>
<p>Often, you may want just some simple throughput limiting at a steady speed.
Then, you only use the first Speed register (at the address offset 0x14).
You can ignore the Interval Length register and, in most cases, also the Section Length register.</p>
<p><strong>Limitation of the Speed register</strong></p>
<p>In one particular case, you must pay attention to the Section Length register.
Here, we return to the constants mentioned above that are added to the currently accumulated data (to avoid surpassing the configured speed).
But setting the Speed register value less or equal to the value of the constant will result in no throughput at all!
Do not despair, there is a workaround available.
You can extend the Section Length and change (increase) the Speed accordingly.
Before understanding how that might work in practice, let’s first look into configuring the Speed.</p>
<p><strong>Speed conversions</strong></p>
<p>Configuring the Speed is a bit tricky because the value of the Speed register is in Bytes (or Packets) per Section, and the length of the Section (see the Section Length parameter) is in clock ticks.
Hence, the desired speed, e.g., in Gbps, must be converted before being written into the Speed register.
There are conversion functions in the provided script (./sw/rate_limiter.py) that you may take inspiration from:</p>
<ul class="simple">
<li><p>for conversion from Gbps to Bytes per Section (Bscn), there is the <code class="docutils literal notranslate"><span class="pre">conv_Gbs2Bscn</span></code> function</p></li>
<li><p>for conversion from Bscn to Gbps, there is the <code class="docutils literal notranslate"><span class="pre">conv_Bscn2Gbs</span></code> function</p></li>
<li><p>for conversion from packets per second (pps or Ps) to packets per Section (Pscn), there is the <code class="docutils literal notranslate"><span class="pre">conv_Ps2Pscn</span></code> function</p></li>
<li><p>for conversion from Pscn to pps, there is the <code class="docutils literal notranslate"><span class="pre">conv_Pscn2Ps</span></code> function</p></li>
</ul>
<p>However, the basic formula is: Xscn = Xps [X/seconds] / (Frequency [Hz] / SectionLength [clock ticks]), where the <code class="docutils literal notranslate"><span class="pre">X</span></code> (also in Xscn and Xps) represents Bytes or Packets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code class="docutils literal notranslate"><span class="pre">Xps</span></code> is in bits (Gbps, Mbps, …), it is necessary to divide it by 8 to get Bytes!
Or you can convert the speed into Bytes per second upfront.</p>
</div>
<p><strong>Adjusting Section Length</strong></p>
<p>The adjustment of the Section Length is necessary in cases when low output speeds are required.
These are the minimum values (after conversion) the Speed register can have:</p>
<ul class="simple">
<li><p>pps limiting: <code class="docutils literal notranslate"><span class="pre">MinimumSpeed</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">MFB_REGIONS*1</span></code> packets per Section (100G: MFB_REGIONS = 1, 400G: MFB_REGIONS = 4),</p></li>
<li><p>bps limiting: <code class="docutils literal notranslate"><span class="pre">MinimumSpeed</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">3*MFB_WORD_WIDTH/8</span></code> Bytes per Section (100G: MFB_WORD_WIDTH = 512b, 400G: MFB_WORD_WIDTH = 2048b)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Setting the value of the Speed register below the mentioned limits causes the traffic to halt.</p>
</div>
<p>The formula to meet the condition is the following: Xps [X/seconds] / (Frequency [Hz] / SectionLength [clock ticks]) &gt;= MinimumSpeed.
The left side of this equation is the value of the Speed register (Xscn), and the MinimumSpeed value on the right side is the constant defined above.
The goal is to determine whether the Section Length is large enough and, if not, increase it and use the new value to calculate the Speed register value.
A simple solution follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">SectionLength</span> <span class="o">&lt;</span> <span class="n">MinimumSpeed</span> <span class="o">*</span> <span class="n">Frequency</span> <span class="o">/</span> <span class="n">Xps</span><span class="p">):</span> <span class="c1"># if this condition is met, the Speed will be below the limit</span>
    <span class="n">SectionLength</span> <span class="o">=</span> <span class="p">(</span><span class="n">MinimumSpeed</span> <span class="o">*</span> <span class="n">Frequency</span> <span class="o">/</span> <span class="n">Xps</span><span class="p">)</span> <span class="c1"># sets the Section Length to the smallest possible value - the Speed register value will be the MinimumSpeed</span>
</pre></div>
</div>
<p>This has to be done before setting the Speed register value.
Following this, you should convert your desired speed into the Xscn format using this (potentially new) value of Section Length.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Bscn</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">bps</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Frequency</span><span class="o">/</span><span class="n">SectionLength</span><span class="p">))</span> <span class="c1"># The basic formula mentioned in the &quot;Speed conversions&quot; section above.</span>
</pre></div>
</div>
<p><strong>Types of the Auxiliary flags</strong></p>
<p>As previously mentioned, there are two Auxiliary flags in the Status register.
Bit number four is the flag allowing the user to reset the pointer to the current Speed register manually.
It is useful only when using multiple intervals.
In the default state, after stopping the traffic flow (returning to IDLE or CONFIGURATION mode), the pointer to the current Speed register does not change.
This flag (which must be set only in the IDLE state) resets the pointer to the first Speed register.</p>
<p>Bit number five switches between the types of limiting.
When this bit is 0 (default), the output speed is limited according to bps - the value of the Speed register is perceived to be in Bytes per Section.
When it is set to 1, the output speed is limited according to pps, and the value of the Speed register is perceived to be in Packets per Section.
This bit can be changed independently on its current state, but be aware of its impact in the RUN state - suddenly, the Speed register will have the same value but in different units (Bscn &lt;-&gt; Pscn).</p>
<p><strong>Setting the Auxiliary flags</strong></p>
<p>To set the auxiliary flags, set the AUXILIARY FLAG (bit number three) to 1 and with that (in the same write request) whatever auxiliary bits you need.
Both Auxiliary bits are always set simultaneously, so for data consistency, either store their values (keep them in the memory) or read their values before every change.
For example, if you’re using packet limiting - the LIMITING TYPE flag is set to 1 - and then you wish to reset the pointer in the IDLE state, make sure you also set the LIMITING TYPE flag to 1 because this single write request will overwrite both bits.</p>
</section>
<section id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>To simulate intervals of different lengths, set the same output speed to more Intervals in a row.</p></li>
<li><p>Remember to set consecutive speed registers. Upon encountering a gap in the form of an invalid (not set) speed register, the component loops from the first speed again.</p></li>
<li><p>When reading a speed register, the most significant bit indicates whether the value was configured during the last configuration and is, therefore, valid (1) or not valid (0).</p></li>
<li><p>The Speed registers are reset When switched to the IDLE or CONFIGURATION state.</p></li>
<li><p>The preferred way to interact with the component is using the provided software (Python script).</p></li>
<li><p>The component supports the BE signal internally, although its usage is not needed anywhere in the current version.</p></li>
<li><p>When using ‘byte limiting’ in the verification, the output speed can (under some extreme circumstances) exceed the limit a little (packets on the border of two sections are counted as a whole to only one of them).</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../enabler/readme.html" class="btn btn-neutral float-left" title="MFB Enabler" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../packet_delayer/readme.html" class="btn btn-neutral float-right" title="Packet Delayer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, CESNET z.s.p.o..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>