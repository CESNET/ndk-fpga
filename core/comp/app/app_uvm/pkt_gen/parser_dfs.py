#!/bin/python3

#  SPDX-License-Identifier: BSD-3-Clause
#
#  simple packet generator. Packet are generated by dfs algorithm.
#  In this file is resolving how prototoclols follows.
#
#  Copyright (C) 2022 CESNET
#  Author(s):
#    Radek IÅ¡a <isa@cesnet.cz>

from config import packet_config
from parser import parser as Parser


class dfs_item:
    def __init__(self, protocol, cfg):
        self.protocol     = protocol
        self.index        = 0
        self.cfg          = cfg.copy()
        proto_next = protocol.protocol_next(self.cfg)
        self.protocols_next = []
        for it in proto_next:
            if (proto_next[it] != 0):
                self.protocols_next.append(it)

    def last(self):
        return len(self.protocols_next) == 0

    def next(self):
        if self.protocols_next is None or self.index >= len(self.protocols_next):
            return None

        ret = self.protocols_next[self.index]
        self.index += 1
        return ret


class parser_dfs(Parser):
    def __init__(self, pcap_file, cfg, seed):
        super().__init__(pcap_file, cfg, seed)

    def gen(self):
        next_items = []

        cfg_act  = packet_config(self.cfg)
        item = dfs_item(self.protocols["ETH"], cfg_act)
        next_items.append(item)

        packets = 0
        while len(next_items) > 0:
            # get last item
            item = next_items[-1]
            # get next generated protocol
            proto_next = item.next()

            if not item.last():
                if proto_next is not None:
                    item_next = dfs_item(self.protocols[proto_next], item.cfg)
                    next_items.append(item_next)
                else:
                    #remove last index there is no next protocol
                    del next_items[-1]
            else:
                #generate packet
                packets += 1
                packet = scapy.packet.Packet()

                for it in next_items:
                    pkt_proto = it.protocol.protocol_add(it.cfg)
                    if pkt_proto is not None:
                        packet = packet / pkt_proto

                #write packet
                self.write(packet)
                #remove last index
                del next_items[-1]

        print("PACKETS %d" % (packets))
        pass
