#!/bin/python3

#  SPDX-License-Identifier: BSD-3-Clause
#
#  simple packet generator. Packet are generated by dfs algorithm.
#  In this file is resolving how prototoclols follows.
#
#  Copyright (C) 2022 CESNET
#  Author(s):
#    Radek IÅ¡a <isa@cesnet.cz>

from config import *
from parser import *

class dfs_item:
    def __init__(self, protocol, cfg):
        self.protocol     = protocol
        self.index        = 0
        self.cfg          = cfg.copy()
        proto_next = protocol.protocol_next(self.cfg)
        self.protocols_next = []
        for it in proto_next:
            if (proto_next[it] != 0):
                self.protocols_next.append(it)

    def last(self):
        return len(self.protocols_next) == 0;

    def next(self):
        if (self.protocols_next == None or self.index >= len(self.protocols_next)):
            return None

        ret = self.protocols_next[self.index]
        self.index += 1
        return ret


class parser_dfs(parser):
    def __init__(self, pcap_file, cfg, seed):
        super().__init__(pcap_file, cfg, seed);

    def gen(self):
        next_items = []

        cfg_act  = packet_config(self.cfg);
        item = dfs_item(self.protocols["ETH"], cfg_act);
        next_items.append(item)

        packets = 0
        while (len(next_items) > 0):
            # get last item
            item = next_items[-1];
            # get next generated protocol
            proto_next = item.next()

            if (not item.last()):
                if (proto_next != None):
                    item_next = dfs_item(self.protocols[proto_next], item.cfg);
                    next_items.append(item_next)
                else:
                    #remove last index there is no next protocol
                    del next_items[-1]
            else:
                #generate packet
                packets += 1
                packet = scapy.packet.Packet()

                for it in next_items:
                    pkt_proto = it.protocol.protocol_add(it.cfg)
                    if (pkt_proto != None):
                        packet     = packet/pkt_proto

                #write packet
                self.write(packet)
                #remove last index
                del next_items[-1]

        print ("PACKETS %d" % (packets))
        pass

